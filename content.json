{"meta":{"title":"feYqb","subtitle":"never give up reading!","description":"never give up reading!","author":"feYqb","url":"http://yoursite.com"},"pages":[{"title":"关于我们","date":"2017-07-24T05:24:32.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"壹钱包前端团队前端的世界一直在变化着，在各种熟悉的语言进化中迅速的化学反应。也许你和我们一样，对前端的理解也在不断刷新。 我们犹如一群站在互联网风口上的攻城狮，眼前的空间充满了未知，需要我们去开拓去开垦，需要我们逆风而上，不为别的，只为能在这虚拟与现实交错的世界里昂首飞翔！ 共同的理想和愿景把我们聚集到一起，为了一件件简单而又快乐的事情努力，我们深知手中的事情在改变世界，我们必须专业，必须严谨，必须乐于分享！ 无限未来等着你我，一起发现！"},{"title":"codeReview","date":"2017-07-24T05:16:54.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"codeReview/index.html","permalink":"http://yoursite.com/codeReview/index.html","excerpt":"","text":""},{"title":"归档","date":"2017-07-25T01:40:59.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""}],"posts":[{"title":"README","slug":"README","date":"2017-09-29T01:42:50.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"codeReview/README/","link":"","permalink":"http://yoursite.com/codeReview/README/","excerpt":"","text":"规范codeReviewcodeReview的文章，请在头部添加categories分类为codeReview，编译时会自动添加到codeReview文章列表 目前categories只有codeReview，react，其他类型统一归类为other。如需新增分类，请联系管理员。To Be Continued..","categories":[{"name":"codeReview","slug":"codeReview","permalink":"http://yoursite.com/categories/codeReview/"}],"tags":[]},{"title":"如何新建codeReview页面？","slug":"code-guide","date":"2017-08-16T06:01:22.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"codeReview/code-guide/","link":"","permalink":"http://yoursite.com/codeReview/code-guide/","excerpt":"","text":"所有文章默认以md形式保存在Hexo目录下的source/_post文件夹中。或者可以直接在该目录下新建md类型的文档，就能在执行hexo g的时候渲染。新建的文章需要添加一些yml信息，如下： 12345678---title:Redux //标题date: 2017-03-21 19:11:05 //编辑这篇文章的时间tags: //文章tag- React框架- RN技术- Node技术--- 新建codeReview:（为文章添加分类）如果要新建一篇code-review，需要为文章添加其分类信息categories: codeReview系统会自动为其归档为codeReview类目 123456789---title: 第二篇code reviewdate: 2017-07-28 19:02:08tags:categories:- codeReview---some code review codeReview的文章，请在头部添加categories分类为codeReview，编译时会自动添加到codeReview文章列表 PS: 我们会定期部署codeReview库内部的md文档 目前categories只有codeReview，react，其他类型统一归类为other。如需新增分类，请联系管理员。","categories":[{"name":"codeReview","slug":"codeReview","permalink":"http://yoursite.com/categories/codeReview/"}],"tags":[]},{"title":"redux","slug":"redux","date":"2017-03-28T10:06:37.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"react/redux/","link":"","permalink":"http://yoursite.com/react/redux/","excerpt":"","text":"redux推荐文档 redux 生态系统:http://cn.redux.js.org/docs/introduction/Ecosystem.html 中文官方文档: http://cn.redux.js.org/index.html 英文官方文档: http://redux.js.org/ github精简教程: https://github.com/react-guide/redux-tutorial-cn#redux-tutorial 什么是redux 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。 Redux是JS状态容器.提供可预测化的状态管理. 三大原则 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的 惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers。 现实案例公司项目代码trunk管理 … 对应关系 职责 我们 action 表达修改trunk 代码的意图 双星级想出来的修改的方法 reducers 改变公司代码 双星级 combine reducer reducers集合 trunk store 存储公司代码状态的地方 Action 表达我们修改store的意图 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state store 数据的唯一来源 一般来说你会通过 store.dispatch() 将 action 传到 store Action 创建函数 在 Redux 中的 action 创建函数只是简单的返回一个 action123456function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; Action.js123456789101112131415161718192021222324252627282930313233/* * action 类型 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'/* * 其它的常量 */export const VisibilityFilters = &#123; SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'&#125;/* * action 创建函数 */export function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;export function toggleTodo(index) &#123; return &#123; type: TOGGLE_TODO, index &#125;&#125;export function setVisibilityFilter(filter) &#123; return &#123; type: SET_VISIBILITY_FILTER, filter &#125;&#125; Reducer Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。 Action 处理 reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。 不要直接修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。 在写reducer时候,注意store的数据结构 纯函数 纯函数是指 不依赖于且不改变它作用域之外的变量状态的函数。 也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。 connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])[mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。 该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。 如果你省略了这个参数，你的组件将不会监听 Redux store。 如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。 [mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。 如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。 如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。 如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"RN技术","slug":"RN技术","permalink":"http://yoursite.com/tags/RN技术/"}]},{"title":"回归技术教程，做系列分享","slug":"background","date":"2017-03-26T09:10:09.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"other/background/","link":"","permalink":"http://yoursite.com/other/background/","excerpt":"","text":"背景：今年我和很多同学谈17年KPI的时候，发现很多同学都在说同一件事，就是想学习，想团队有一个持续的分享会，想有一个大牛来指导他们去学习。所以能看出来，大家都渴望新知识，都想团队有个持续的分享会。 现状：目前分享会形式主要是‘散养’，大家自主选课题，自己感兴趣的主题分享，这种形式的分享有两个很大的困难 不固定，不持久，想来一发就一发。 主题与大家不match主讲在上面说，下面的同学用很渴望的眼神认真的听着，但就是听不懂。我一般一次分享会做完后，我都用问过其中的一些同学，没对主讲课题做一些基础的准备的话，绝大多数人都是这种情况。所以这种形式的分享最佳收益者是主讲人，对于听众效果应该不是最好的。所以年初来，我一直在考虑解决这个问题，能给大家一个固定又持久，不管对主讲还是对听众都有收获的分享会。 正因为有目前分享会有这种问题，而且我们团队人越来越多啦，我相信团队对于这种分享技术的氛围会越来越强烈。所以我一直在想以哪种分享形式来解决这些问题。目前我有一些想法，也跟佳敏做了讨论，他还是肯定提倡我这种做法。所以我觉得是时候跟大家说下，看看大家的反馈。 新分享会新主题增加： “回归技术教程，做系列分享” 形式：引入学校上课形式，会以17年团队技术KPI的三块： react框架、RN技术、node技术 找三本经典教程，去买PDF版本，分发给大家。分享会根据制定出一个课程表，以章节作为一个课时，每周一节课来分享三本教程中的每一章内容。量不大吧？这样只要大家提前去看，带着每章的问题来听课，内容上跟讲师也能match上，可能效果会更好些。 分享时间： 以课程表为准 老师：每条线都以目前这三个技术方向的几个主要负责人来作为主讲老师，持续系列分享。当然我更希望是在坐的每位同学，提前看教程，自主提出当老师。我觉得大家都是从0基础开始，每个人都有资格来当老师，哪怕当老师犯了错，下面有经验的学生也会纠正，对你本人收益也是最大的。所以我提倡这种自主行为，为此我会设立讲师奖励。 奖励：计划每个季度，对前三名讲师给予买书补贴（具体费用如下）。12一次/一季度的前三名次数讲师: (80+100+120) * 4个季度 = 1200一次/一季度的 Happy Time: 250 * 4 = 1000 分享博客站点： 1. 分享会讲师内容 2. 大家工作上或学习中的体会","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"node线分享课程计划","slug":"schedule","date":"2017-03-21T11:11:05.000Z","updated":"2017-09-29T01:42:50.000Z","comments":true,"path":"node/schedule/","link":"","permalink":"http://yoursite.com/node/schedule/","excerpt":"","text":"node线分享书籍 《了不起的nodejs》：分10个课时 《深入浅出nodejs》：分10个课时 课程表《了不起的nodejs》 课时章节 日期 讲师 1. 基础知识 陈宇 2. CLI 倪敏 3. TCP HTTP 徐佳 4. Connect &amp; Express 林宇宏 5. 数据库 林宇宏 6. Redis 倪敏 7. 测试 陈宇 《深入浅出nodejs》 课时章节 日期 讲师 1. Chap1 - Chap2 Node简介及模块 徐佳 2. Chap3 - Chap4 异步IO/异步编程 徐佳 3. Chap5 内存管理 徐佳 4. Chap6 理解Buffer 徐佳 5. Chap7 网络编程 徐佳 6. Chap8 构建Web应用 徐佳 7. Chap9 玩转进程 徐佳 8. Chap10 测试 徐佳 9. Chap10 产品化 徐佳 10. 附录功能-调试Node\\Node编码规范 徐佳","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"RN技术","slug":"RN技术","permalink":"http://yoursite.com/tags/RN技术/"},{"name":"react框架","slug":"react框架","permalink":"http://yoursite.com/tags/react框架/"},{"name":"node技术","slug":"node技术","permalink":"http://yoursite.com/tags/node技术/"}]}]}